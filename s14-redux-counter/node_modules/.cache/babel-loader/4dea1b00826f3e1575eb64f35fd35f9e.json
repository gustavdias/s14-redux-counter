{"ast":null,"code":"//!the reducer was splitted (into counter.js & result.js) and is no longer in use.\n//using multiple reducers - split it up by feature and them redux will combine all in one reducer\n//one for counter and one for results.\n//? it is a good practice to outsource your action types into constants you can use in your application so that you always just import a constant and eliminate the danger of mistyping,\nimport * as actionTypes from \"../actions\"; // actionTypes is an object which has all the const as properties from actions\n\nconst initialState = {\n  counter: 0,\n  results: [] //updating state immutably\n\n};\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case actionTypes.STORE_RESULT:\n      return { ...state,\n        //return a javascript object where we distribute the old state thus keeping the counter but then we set results here:\n        //* results: state.results.concat({ id: new Date(), value: state.counter }), //concat is like push, but creates a new array\n        //if we are in a reducer where we need to get a value from the global state, we should simply get it as an action payload\n        results: state.results.concat({\n          id: new Date(),\n          value: action.result\n        }) //? state.counter it is not know\n        //because this local initial state in this reducer doesn't have a counter property. inside this reducer function, it basically has no access to the global state\n\n      };\n\n    case actionTypes.DELETE_RESULT:\n      //   const id = 2;\n      //   state.results.splice(id, 1); //! This mutates the original array\n      //! Volta -  1st way to update Arrays Immutably - Coping the array\n      //   const id = 2;\n      //   const updatedArray = [...state.results];\n      //--------\n      //! Volta - if the elements in state.results were objects as they actually are, the objects themselves are still pointing to the same objects they did before.\n      //? if you change a property in one of the elements themselves, just creating a new array like this isn't enough, if you just plan on removing an object though, that is okay\n      //   updatedArray.splice(id, 1);\n      //--------\n      //! Volta - 2nd way to update Arrays Immutably - filter method - originalArray.filter() - filter returns a new array\n      //. Filter takes a function as an input, the function is executed on each element in the array, it determines whether this element fulfils a certain condition to make it into the new array\n      const updatedArray = state.results.filter(result => result.id !== action.resultElId);\n      return { ...state,\n        results: updatedArray\n      };\n    //* So we get the individual element as an input here, the element or in our case, the result\n    // state.result.filter(result => true); //? if you return true, you return this for every element and therefore, you just created a copy of the old array,\n    //* return true for every element which doesn't have a certain ID\n\n    default:\n      console.log(\"default case\");\n      return state;\n  } //   if (action.type === \"INCREMENT\") {\n  //     return {\n  //       counter: state.counter + 1,\n  //     };\n  //   }\n  //   //DECREMENT\n  //   if (action.type === \"DECREMENT\") {\n  //     return {\n  //       counter: state.counter - 1,\n  //     };\n  //   }\n  //   //ADD\n  //   if (action.type === \"ADD\") {\n  //     return {\n  //       counter: state.counter  + action.payload,\n  //     };\n  //   }\n  //   //SUBTRACT\n  //   if (action.type === \"SUBTRACT\") {\n  //     return {\n  //       counter: state.counter - action.payload,\n  //     };\n  //   }\n  //   return state;\n\n};\n\nexport default reducer;","map":{"version":3,"sources":["/home/khan/code/react-c-g-u/s14-redux/s14-redux-counter/src/store/reducers/result.js"],"names":["actionTypes","initialState","counter","results","reducer","state","action","type","STORE_RESULT","concat","id","Date","value","result","DELETE_RESULT","updatedArray","filter","resultElId","console","log"],"mappings":"AAAA;AACA;AACA;AAEA;AACA,OAAO,KAAKA,WAAZ,MAA6B,YAA7B,C,CAA2C;;AAE3C,MAAMC,YAAY,GAAG;AACnBC,EAAAA,OAAO,EAAE,CADU;AAEnBC,EAAAA,OAAO,EAAE,EAFU,CAEN;;AAFM,CAArB;;AAKA,MAAMC,OAAO,GAAG,CAACC,KAAK,GAAGJ,YAAT,EAAuBK,MAAvB,KAAkC;AAChD,UAAQA,MAAM,CAACC,IAAf;AACE,SAAKP,WAAW,CAACQ,YAAjB;AACE,aAAO,EACL,GAAGH,KADE;AAEL;AACA;AACA;AACAF,QAAAA,OAAO,EAAEE,KAAK,CAACF,OAAN,CAAcM,MAAd,CAAqB;AAAEC,UAAAA,EAAE,EAAE,IAAIC,IAAJ,EAAN;AAAkBC,UAAAA,KAAK,EAAEN,MAAM,CAACO;AAAhC,SAArB,CALJ,CAML;AACA;;AAPK,OAAP;;AASF,SAAKb,WAAW,CAACc,aAAjB;AACE;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA,YAAMC,YAAY,GAAGV,KAAK,CAACF,OAAN,CAAca,MAAd,CAClBH,MAAD,IAAYA,MAAM,CAACH,EAAP,KAAcJ,MAAM,CAACW,UADd,CAArB;AAIA,aAAO,EACL,GAAGZ,KADE;AAELF,QAAAA,OAAO,EAAEY;AAFJ,OAAP;AAIF;AACA;AACA;;AACA;AACEG,MAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACA,aAAOd,KAAP;AAxCJ,GADgD,CA4ChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACD,CAtED;;AAwEA,eAAeD,OAAf","sourcesContent":["//!the reducer was splitted (into counter.js & result.js) and is no longer in use.\n//using multiple reducers - split it up by feature and them redux will combine all in one reducer\n//one for counter and one for results.\n\n//? it is a good practice to outsource your action types into constants you can use in your application so that you always just import a constant and eliminate the danger of mistyping,\nimport * as actionTypes from \"../actions\"; // actionTypes is an object which has all the const as properties from actions\n\nconst initialState = {\n  counter: 0,\n  results: [], //updating state immutably\n};\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case actionTypes.STORE_RESULT:\n      return {\n        ...state,\n        //return a javascript object where we distribute the old state thus keeping the counter but then we set results here:\n        //* results: state.results.concat({ id: new Date(), value: state.counter }), //concat is like push, but creates a new array\n        //if we are in a reducer where we need to get a value from the global state, we should simply get it as an action payload\n        results: state.results.concat({ id: new Date(), value: action.result }),\n        //? state.counter it is not know\n        //because this local initial state in this reducer doesn't have a counter property. inside this reducer function, it basically has no access to the global state\n      };\n    case actionTypes.DELETE_RESULT:\n      //   const id = 2;\n      //   state.results.splice(id, 1); //! This mutates the original array\n\n      //! Volta -  1st way to update Arrays Immutably - Coping the array\n      //   const id = 2;\n      //   const updatedArray = [...state.results];\n      //--------\n      //! Volta - if the elements in state.results were objects as they actually are, the objects themselves are still pointing to the same objects they did before.\n      //? if you change a property in one of the elements themselves, just creating a new array like this isn't enough, if you just plan on removing an object though, that is okay\n      //   updatedArray.splice(id, 1);\n\n      //--------\n      //! Volta - 2nd way to update Arrays Immutably - filter method - originalArray.filter() - filter returns a new array\n      //. Filter takes a function as an input, the function is executed on each element in the array, it determines whether this element fulfils a certain condition to make it into the new array\n\n      const updatedArray = state.results.filter(\n        (result) => result.id !== action.resultElId\n      );\n\n      return {\n        ...state,\n        results: updatedArray,\n      };\n    //* So we get the individual element as an input here, the element or in our case, the result\n    // state.result.filter(result => true); //? if you return true, you return this for every element and therefore, you just created a copy of the old array,\n    //* return true for every element which doesn't have a certain ID\n    default:\n      console.log(\"default case\");\n      return state;\n  }\n\n  //   if (action.type === \"INCREMENT\") {\n  //     return {\n  //       counter: state.counter + 1,\n  //     };\n  //   }\n  //   //DECREMENT\n  //   if (action.type === \"DECREMENT\") {\n  //     return {\n  //       counter: state.counter - 1,\n  //     };\n  //   }\n\n  //   //ADD\n  //   if (action.type === \"ADD\") {\n  //     return {\n  //       counter: state.counter  + action.payload,\n  //     };\n  //   }\n  //   //SUBTRACT\n  //   if (action.type === \"SUBTRACT\") {\n  //     return {\n  //       counter: state.counter - action.payload,\n  //     };\n  //   }\n\n  //   return state;\n};\n\nexport default reducer;\n"]},"metadata":{},"sourceType":"module"}