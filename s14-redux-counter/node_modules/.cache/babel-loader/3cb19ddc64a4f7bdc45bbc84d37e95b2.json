{"ast":null,"code":"const initialState = {\n  counter: 0,\n  results: [] //updating state immutably\n\n};\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"INCREMENT\":\n      //since there is return, you don't need to use break\n      //   return {\n      //! counter: state.counter + 1, //since know the state is a object with a number and an array, I can't use this\n      //if you use it, it will eliminate results array, counter: state.counter will be the new state instead\n      //*instead we should copy the old state properties and then only update the ones which need updating\n      // ! Updating State Immutably - passing an empty javascript object us to the first argument and the old javascript object we want to copy as the second state\n      //? It isn't a deep clone\n      const newState = Object.assign({}, state);\n      newState.counter = state.counter + 1;\n      return newState;\n    // };\n\n    case \"DECREMENT\":\n      //   return {\n      //     counter: state.counter - 1,\n      //   };\n      //! Updating State Immutably\n      return { ...state,\n        counter: state.counter - 1\n      };\n    //* This simply tells javascript return a javascript object, take all the properties and values of the state argument which is our old state, distribute these properties with their values in this new object and then since we define an additional property, add this property to the object or if it already was present due to us distributing the old state as it would be for the counter, this is part of the old state, overwrite this but only this, leave results untouched.\n\n    case \"ADD\":\n      //   return {\n      //     counter: state.counter + action.payload,\n      //   };\n      //! Updating State Immutably\n      return { ...state,\n        counter: state.counter + action.val\n      };\n\n    case \"SUBTRACT\":\n      //   return {\n      //     counter: state.counter - action.payload,\n      //   };\n      //! Updating State Immutably\n      return { ...state,\n        counter: state.counter - action.val\n      };\n\n    case \"STORE_RESULT\":\n      return { ...state,\n        //return a javascript object where we distribute the old state thus keeping the counter but then we set results here:\n        results: state.results.concat({\n          id: new Date(),\n          value: state.counter\n        }) //concat is like push, but creates a new array\n\n      };\n\n    default:\n      console.log(\"default case\");\n      return state;\n  } //   if (action.type === \"INCREMENT\") {\n  //     return {\n  //       counter: state.counter + 1,\n  //     };\n  //   }\n  //   //DECREMENT\n  //   if (action.type === \"DECREMENT\") {\n  //     return {\n  //       counter: state.counter - 1,\n  //     };\n  //   }\n  //   //ADD\n  //   if (action.type === \"ADD\") {\n  //     return {\n  //       counter: state.counter  + action.payload,\n  //     };\n  //   }\n  //   //SUBTRACT\n  //   if (action.type === \"SUBTRACT\") {\n  //     return {\n  //       counter: state.counter - action.payload,\n  //     };\n  //   }\n  //   return state;\n\n};\n\nexport default reducer;","map":{"version":3,"sources":["/home/khan/code/react-c-g-u/s14-redux/s14-redux-counter/src/store/reducer.js"],"names":["initialState","counter","results","reducer","state","action","type","newState","Object","assign","val","concat","id","Date","value","console","log"],"mappings":"AAAA,MAAMA,YAAY,GAAG;AACnBC,EAAAA,OAAO,EAAE,CADU;AAEnBC,EAAAA,OAAO,EAAE,EAFU,CAEN;;AAFM,CAArB;;AAKA,MAAMC,OAAO,GAAG,CAACC,KAAK,GAAGJ,YAAT,EAAuBK,MAAvB,KAAkC;AAChD,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,WAAL;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAMC,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAlB,CAAjB;AACAG,MAAAA,QAAQ,CAACN,OAAT,GAAmBG,KAAK,CAACH,OAAN,GAAgB,CAAnC;AACA,aAAOM,QAAP;AACF;;AACA,SAAK,WAAL;AACE;AACA;AACA;AACA;AACA,aAAO,EACL,GAAGH,KADE;AAELH,QAAAA,OAAO,EAAEG,KAAK,CAACH,OAAN,GAAgB;AAFpB,OAAP;AAIF;;AACA,SAAK,KAAL;AACE;AACA;AACA;AACA;AACA,aAAO,EACL,GAAGG,KADE;AAELH,QAAAA,OAAO,EAAEG,KAAK,CAACH,OAAN,GAAgBI,MAAM,CAACK;AAF3B,OAAP;;AAKF,SAAK,UAAL;AACE;AACA;AACA;AACA;AACA,aAAO,EACL,GAAGN,KADE;AAELH,QAAAA,OAAO,EAAEG,KAAK,CAACH,OAAN,GAAgBI,MAAM,CAACK;AAF3B,OAAP;;AAIF,SAAK,cAAL;AACE,aAAO,EACL,GAAGN,KADE;AAEL;AACAF,QAAAA,OAAO,EAAEE,KAAK,CAACF,OAAN,CAAcS,MAAd,CAAqB;AAAEC,UAAAA,EAAE,EAAE,IAAIC,IAAJ,EAAN;AAAkBC,UAAAA,KAAK,EAAEV,KAAK,CAACH;AAA/B,SAArB,CAHJ,CAGoE;;AAHpE,OAAP;;AAKF;AACEc,MAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACA,aAAOZ,KAAP;AAlDJ,GADgD,CAsDhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACD,CAhFD;;AAkFA,eAAeD,OAAf","sourcesContent":["const initialState = {\n  counter: 0,\n  results: [], //updating state immutably\n};\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"INCREMENT\":\n      //since there is return, you don't need to use break\n      //   return {\n      //! counter: state.counter + 1, //since know the state is a object with a number and an array, I can't use this\n      //if you use it, it will eliminate results array, counter: state.counter will be the new state instead\n      //*instead we should copy the old state properties and then only update the ones which need updating\n      // ! Updating State Immutably - passing an empty javascript object us to the first argument and the old javascript object we want to copy as the second state\n      //? It isn't a deep clone\n      const newState = Object.assign({}, state);\n      newState.counter = state.counter + 1;\n      return newState;\n    // };\n    case \"DECREMENT\":\n      //   return {\n      //     counter: state.counter - 1,\n      //   };\n      //! Updating State Immutably\n      return {\n        ...state,\n        counter: state.counter - 1,\n      };\n    //* This simply tells javascript return a javascript object, take all the properties and values of the state argument which is our old state, distribute these properties with their values in this new object and then since we define an additional property, add this property to the object or if it already was present due to us distributing the old state as it would be for the counter, this is part of the old state, overwrite this but only this, leave results untouched.\n    case \"ADD\":\n      //   return {\n      //     counter: state.counter + action.payload,\n      //   };\n      //! Updating State Immutably\n      return {\n        ...state,\n        counter: state.counter + action.val,\n      };\n\n    case \"SUBTRACT\":\n      //   return {\n      //     counter: state.counter - action.payload,\n      //   };\n      //! Updating State Immutably\n      return {\n        ...state,\n        counter: state.counter - action.val,\n      };\n    case \"STORE_RESULT\":\n      return {\n        ...state,\n        //return a javascript object where we distribute the old state thus keeping the counter but then we set results here:\n        results: state.results.concat({ id: new Date(), value: state.counter }), //concat is like push, but creates a new array\n      };\n    default:\n      console.log(\"default case\");\n      return state;\n  }\n\n  //   if (action.type === \"INCREMENT\") {\n  //     return {\n  //       counter: state.counter + 1,\n  //     };\n  //   }\n  //   //DECREMENT\n  //   if (action.type === \"DECREMENT\") {\n  //     return {\n  //       counter: state.counter - 1,\n  //     };\n  //   }\n\n  //   //ADD\n  //   if (action.type === \"ADD\") {\n  //     return {\n  //       counter: state.counter  + action.payload,\n  //     };\n  //   }\n  //   //SUBTRACT\n  //   if (action.type === \"SUBTRACT\") {\n  //     return {\n  //       counter: state.counter - action.payload,\n  //     };\n  //   }\n\n  //   return state;\n};\n\nexport default reducer;\n"]},"metadata":{},"sourceType":"module"}