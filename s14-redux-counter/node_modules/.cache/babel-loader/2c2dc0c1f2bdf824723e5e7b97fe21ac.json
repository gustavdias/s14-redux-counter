{"ast":null,"code":"const initialState = {\n  counter: 0,\n  results: [] //updating state immutably\n\n};\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"INCREMENT\":\n      //since there is return, you don't need to use break\n      //   return {\n      //! counter: state.counter + 1, //since know the state is a object with a number and an array, I can't use this\n      //if you use it, it will eliminate results array, counter: state.counter will be the new state instead\n      //*instead we should copy the old state properties and then only update the ones which need updating\n      // ! Updating State Immutably - passing an empty javascript object us to the first argument and the old javascript object we want to copy as the second state\n      //? It isn't a deep clone\n      const newState = Object.assign({}, state);\n      newState.counter = state.counter + 1;\n      return newState;\n    // };\n\n    case \"DECREMENT\":\n      //   return {\n      //     counter: state.counter - 1,\n      //   };\n      //! Updating State Immutably\n      return { ...state,\n        counter: state.counter - 1\n      };\n\n    case \"ADD\":\n      return { ...state,\n        counter: state.counter + action.val\n      };\n    //! Updating State Immutably\n\n    case \"SUBTRACT\":\n      return { ...state,\n        counter: state.counter - action.val\n      };\n    //! Updating State Immutably\n\n    case \"STORE_RESULT\":\n      return;\n\n    default:\n      console.log(\"default case\");\n      return state;\n  } //   if (action.type === \"INCREMENT\") {\n  //     return {\n  //       counter: state.counter + 1,\n  //     };\n  //   }\n  //   //DECREMENT\n  //   if (action.type === \"DECREMENT\") {\n  //     return {\n  //       counter: state.counter - 1,\n  //     };\n  //   }\n  //   //ADD\n  //   if (action.type === \"ADD\") {\n  //     return {\n  //       counter: state.counter  + action.payload,\n  //     };\n  //   }\n  //   //SUBTRACT\n  //   if (action.type === \"SUBTRACT\") {\n  //     return {\n  //       counter: state.counter - action.payload,\n  //     };\n  //   }\n  //   return state;\n\n};\n\nexport default reducer;","map":{"version":3,"sources":["/home/khan/code/react-c-g-u/s14-redux/s14-redux-counter/src/store/reducer.js"],"names":["initialState","counter","results","reducer","state","action","type","newState","Object","assign","val","console","log"],"mappings":"AAAA,MAAMA,YAAY,GAAG;AACnBC,EAAAA,OAAO,EAAE,CADU;AAEnBC,EAAAA,OAAO,EAAE,EAFU,CAEN;;AAFM,CAArB;;AAKA,MAAMC,OAAO,GAAG,CAACC,KAAK,GAAGJ,YAAT,EAAuBK,MAAvB,KAAkC;AAChD,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,WAAL;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAMC,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAlB,CAAjB;AACAG,MAAAA,QAAQ,CAACN,OAAT,GAAmBG,KAAK,CAACH,OAAN,GAAgB,CAAnC;AACA,aAAOM,QAAP;AACF;;AACA,SAAK,WAAL;AACE;AACA;AACA;AACA;AACA,aAAO,EACL,GAAGH,KADE;AAELH,QAAAA,OAAO,EAAEG,KAAK,CAACH,OAAN,GAAgB;AAFpB,OAAP;;AAIF,SAAK,KAAL;AACE,aAAO,EACL,GAAGG,KADE;AAELH,QAAAA,OAAO,EAAEG,KAAK,CAACH,OAAN,GAAgBI,MAAM,CAACK;AAF3B,OAAP;AAIF;;AAEA,SAAK,UAAL;AACE,aAAO,EACL,GAAGN,KADE;AAELH,QAAAA,OAAO,EAAEG,KAAK,CAACH,OAAN,GAAgBI,MAAM,CAACK;AAF3B,OAAP;AAIF;;AAEA,SAAK,cAAL;AACE;;AACF;AACEC,MAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACA,aAAOR,KAAP;AAxCJ,GADgD,CA4ChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACD,CAtED;;AAwEA,eAAeD,OAAf","sourcesContent":["const initialState = {\n  counter: 0,\n  results: [], //updating state immutably\n};\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"INCREMENT\":\n      //since there is return, you don't need to use break\n      //   return {\n      //! counter: state.counter + 1, //since know the state is a object with a number and an array, I can't use this\n      //if you use it, it will eliminate results array, counter: state.counter will be the new state instead\n      //*instead we should copy the old state properties and then only update the ones which need updating\n      // ! Updating State Immutably - passing an empty javascript object us to the first argument and the old javascript object we want to copy as the second state\n      //? It isn't a deep clone\n      const newState = Object.assign({}, state);\n      newState.counter = state.counter + 1;\n      return newState;\n    // };\n    case \"DECREMENT\":\n      //   return {\n      //     counter: state.counter - 1,\n      //   };\n      //! Updating State Immutably\n      return {\n        ...state,\n        counter: state.counter - 1,\n      };\n    case \"ADD\":\n      return {\n        ...state,\n        counter: state.counter + action.val,\n      };\n    //! Updating State Immutably\n\n    case \"SUBTRACT\":\n      return {\n        ...state,\n        counter: state.counter - action.val,\n      };\n    //! Updating State Immutably\n\n    case \"STORE_RESULT\":\n      return;\n    default:\n      console.log(\"default case\");\n      return state;\n  }\n\n  //   if (action.type === \"INCREMENT\") {\n  //     return {\n  //       counter: state.counter + 1,\n  //     };\n  //   }\n  //   //DECREMENT\n  //   if (action.type === \"DECREMENT\") {\n  //     return {\n  //       counter: state.counter - 1,\n  //     };\n  //   }\n\n  //   //ADD\n  //   if (action.type === \"ADD\") {\n  //     return {\n  //       counter: state.counter  + action.payload,\n  //     };\n  //   }\n  //   //SUBTRACT\n  //   if (action.type === \"SUBTRACT\") {\n  //     return {\n  //       counter: state.counter - action.payload,\n  //     };\n  //   }\n\n  //   return state;\n};\n\nexport default reducer;\n"]},"metadata":{},"sourceType":"module"}